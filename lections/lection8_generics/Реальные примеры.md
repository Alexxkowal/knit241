### **Стандартные классы с Generics**

Java предоставляет множество стандартных классов и интерфейсов, использующих Generics. Это позволяет разработчикам писать типобезопасный и читаемый код.

---

#### **1. HashMap<K, V>**

`HashMap<K, V>` — это структура данных, которая используется для хранения пар "ключ-значение". Generics позволяют указать типы для ключей и значений.

**Синтаксис:**

- `K` — тип ключа (Key).
- `V` — тип значения (Value).

**Пример:**

```java
import java.util.HashMap;
import java.util.Map;

public class HashMapExample {
    public static void main(String[] args) {
        // Объявляем HashMap с типами String для ключей и Integer для значений
        Map<String, Integer> ageMap = new HashMap<>();
        ageMap.put("Alice", 25);
        ageMap.put("Bob", 30);

        // Доступ к значениям
        System.out.println("Alice's age: " + ageMap.get("Alice"));

        // Итерация по паре ключ-значение
        for (Map.Entry<String, Integer> entry : ageMap.entrySet()) {
            System.out.println(entry.getKey() + ": " + entry.getValue());
        }
    }
}
```

**Результат:**

```
Alice's age: 25
Alice: 25
Bob: 30
```

---

#### **2. Optional**

`Optional<T>` — это класс, использующий Generics для представления значения, которое может быть либо присутствующим, либо отсутствующим. Это помогает избежать `NullPointerException`.

**Синтаксис:**

- `T` — тип значения, которое может быть возвращено.

**Пример:**

```java
import java.util.Optional;

public class OptionalExample {
    public static void main(String[] args) {
        Optional<String> optionalValue = Optional.of("Hello Generics");

        // Проверка наличия значения
        if (optionalValue.isPresent()) {
            System.out.println("Value is present: " + optionalValue.get());
        }

        // Работа с отсутствующим значением
        Optional<String> emptyOptional = Optional.empty();
        String defaultValue = emptyOptional.orElse("Default Value");
        System.out.println("Empty optional: " + defaultValue);
    }
}
```

**Результат:**

```
Value is present: Hello Generics
Empty optional: Default Value
```

---

#### **3. Stream**

`Stream<T>` — это интерфейс, использующий Generics для обработки коллекций данных. Generics позволяют указать тип элементов потока.

**Синтаксис:**

- `T` — тип элементов в потоке.

**Пример:**

```java
import java.util.List;
import java.util.stream.Collectors;

public class StreamExample {
    public static void main(String[] args) {
        List<Integer> numbers = List.of(1, 2, 3, 4, 5);

        // Фильтрация и преобразование данных
        List<Integer> evenNumbers = numbers.stream()
                .filter(num -> num % 2 == 0) // Оставляем только чётные числа
                .collect(Collectors.toList());

        System.out.println("Even numbers: " + evenNumbers);
    }
}
```

**Результат:**

```
Even numbers: [2, 4]
```

---

### **Реализация универсального метода фильтрации**

Generics позволяют создавать методы, которые работают с коллекциями любого типа. Это полезно для фильтрации данных.

#### **Пример универсального метода фильтрации**

Метод принимает коллекцию элементов типа `<T>` и предикат, который определяет условие фильтрации.

**Код:**

```java
import java.util.ArrayList;
import java.util.List;
import java.util.function.Predicate;

public class GenericFilter {

    // Универсальный метод фильтрации
    public static <T> List<T> filter(List<T> list, Predicate<T> predicate) {
        List<T> filteredList = new ArrayList<>();
        for (T item : list) {
            if (predicate.test(item)) {
                filteredList.add(item);
            }
        }
        return filteredList;
    }

    public static void main(String[] args) {
        // Пример с числами
        List<Integer> numbers = List.of(1, 2, 3, 4, 5, 6);
        List<Integer> evenNumbers = filter(numbers, num -> num % 2 == 0);
        System.out.println("Even numbers: " + evenNumbers);

        // Пример со строками
        List<String> words = List.of("apple", "banana", "cherry", "date");
        List<String> longWords = filter(words, word -> word.length() > 5);
        System.out.println("Long words: " + longWords);
    }
}
```

**Результат:**

```
Even numbers: [2, 4, 6]
Long words: [banana, cherry]
```

#### **Как это работает?**

1. **Параметр типа `<T>`**:
    
    - Указывает, что метод может работать с любым типом данных.
2. **`Predicate<T>`**:
    
    - Функциональный интерфейс, который принимает объект типа `T` и возвращает `boolean`, определяя, соответствует ли элемент условию.
3. **Гибкость Generics**:
    
    - Метод `filter` можно использовать с любыми типами, например, числами, строками и т.д.

---

### **Резюме**

1. **Стандартные классы с Generics**:
    
    - `HashMap<K, V>` позволяет работать с парами "ключ-значение".
    - `Optional<T>` помогает избежать `NullPointerException`.
    - `Stream<T>` упрощает обработку коллекций с использованием функционального стиля.
2. **Универсальный метод фильтрации**:
    
    - Пример фильтрации показывает, как легко обрабатывать коллекции с разными типами и условиями.